/* tslint:disable */
/* eslint-disable */
/*
YNAB API Endpoints

Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.ynab.com

The version of the OpenAPI document: 1.68.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { ExistingTransaction } from '../models';
// @ts-ignore
import { HybridTransactionsResponse } from '../models';
// @ts-ignore
import { NewTransaction } from '../models';
// @ts-ignore
import { PatchTransactionsWrapper } from '../models';
// @ts-ignore
import { PostTransactionsWrapper } from '../models';
// @ts-ignore
import { PutTransactionWrapper } from '../models';
// @ts-ignore
import { SaveTransactionWithIdOrImportId } from '../models';
// @ts-ignore
import { SaveTransactionsResponse } from '../models';
// @ts-ignore
import { TransactionResponse } from '../models';
// @ts-ignore
import { TransactionsImportResponse } from '../models';
// @ts-ignore
import { TransactionsResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {PostTransactionsWrapper} data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleOrMultiple: async (budgetId: string, data: PostTransactionsWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('createSingleOrMultiple', 'budgetId', budgetId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createSingleOrMultiple', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: data,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a transaction
         * @summary Deletes an existing transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExistingTransaction: async (budgetId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('deleteExistingTransaction', 'budgetId', budgetId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteExistingTransaction', 'transactionId', transactionId)
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId !== undefined ? transactionId : `-transaction_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions/{transaction_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: async (budgetId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getSingleTransaction', 'budgetId', budgetId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getSingleTransaction', 'transactionId', transactionId)
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId !== undefined ? transactionId : `-transaction_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions/{transaction_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedAccounts: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('importLinkedAccounts', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/transactions/import`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions/import',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {string | Date} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByAccount: async (budgetId: string, accountId: string, sinceDate?: string | Date, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('listByAccount', 'budgetId', budgetId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listByAccount', 'accountId', accountId)
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-account_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/accounts/{account_id}/transactions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {string | Date} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByCategory: async (budgetId: string, categoryId: string, sinceDate?: string | Date, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('listByCategory', 'budgetId', budgetId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('listByCategory', 'categoryId', categoryId)
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId !== undefined ? categoryId : `-category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/categories/{category_id}/transactions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {string | Date} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByPayee: async (budgetId: string, payeeId: string, sinceDate?: string | Date, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('listByPayee', 'budgetId', budgetId)
            // verify required parameter 'payeeId' is not null or undefined
            assertParamExists('listByPayee', 'payeeId', payeeId)
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId !== undefined ? payeeId : `-payee_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/payees/{payee_id}/transactions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string | Date} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: async (budgetId: string, sinceDate?: string | Date, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('listTransactions', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {PutTransactionWrapper} data The transaction to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExistingTransaction: async (budgetId: string, transactionId: string, data: PutTransactionWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateExistingTransaction', 'budgetId', budgetId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('updateExistingTransaction', 'transactionId', transactionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateExistingTransaction', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId !== undefined ? transactionId : `-transaction_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: data,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions/{transaction_id}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
         * @param {PatchTransactionsWrapper} data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by its &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.  You should not specify both &#x60;id&#x60; and &#x60;import_id&#x60;.  Updating an &#x60;import_id&#x60; on an existing transaction is not allowed; if an &#x60;import_id&#x60; is specified, it will only be used to lookup the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiple: async (budgetId: string, data: PatchTransactionsWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateMultiple', 'budgetId', budgetId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateMultiple', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId !== undefined ? budgetId : `-budget_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: data,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/budgets/{budget_id}/transactions',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {TransactionsApiCreateSingleOrMultipleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSingleOrMultiple(requestParameters: TransactionsApiCreateSingleOrMultipleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveTransactionsResponse>> {
            const data: PostTransactionsWrapper = {
                transaction: requestParameters.transaction,
                transactions: requestParameters.transactions
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSingleOrMultiple(requestParameters.budgetId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a transaction
         * @summary Deletes an existing transaction
         * @param {TransactionsApiDeleteExistingTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExistingTransaction(requestParameters: TransactionsApiDeleteExistingTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExistingTransaction(requestParameters.budgetId, requestParameters.transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {TransactionsApiGetSingleTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransaction(requestParameters: TransactionsApiGetSingleTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransaction(requestParameters.budgetId, requestParameters.transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {TransactionsApiImportLinkedAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importLinkedAccounts(requestParameters: TransactionsApiImportLinkedAccountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importLinkedAccounts(requestParameters.budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {TransactionsApiListByAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByAccount(requestParameters: TransactionsApiListByAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByAccount(requestParameters.budgetId, requestParameters.accountId, requestParameters.sinceDate, requestParameters.type, requestParameters.lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {TransactionsApiListByCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByCategory(requestParameters: TransactionsApiListByCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HybridTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByCategory(requestParameters.budgetId, requestParameters.categoryId, requestParameters.sinceDate, requestParameters.type, requestParameters.lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {TransactionsApiListByPayeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByPayee(requestParameters: TransactionsApiListByPayeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HybridTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByPayee(requestParameters.budgetId, requestParameters.payeeId, requestParameters.sinceDate, requestParameters.type, requestParameters.lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {TransactionsApiListTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactions(requestParameters: TransactionsApiListTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactions(requestParameters.budgetId, requestParameters.sinceDate, requestParameters.type, requestParameters.lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {TransactionsApiUpdateExistingTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExistingTransaction(requestParameters: TransactionsApiUpdateExistingTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const data: PutTransactionWrapper = {
                transaction: requestParameters.transaction
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExistingTransaction(requestParameters.budgetId, requestParameters.transactionId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {TransactionsApiUpdateMultipleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMultiple(requestParameters: TransactionsApiUpdateMultipleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveTransactionsResponse>> {
            const data: PatchTransactionsWrapper = {
                transactions: requestParameters.transactions
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMultiple(requestParameters.budgetId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {TransactionsApiCreateSingleOrMultipleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleOrMultiple(requestParameters: TransactionsApiCreateSingleOrMultipleRequest, options?: AxiosRequestConfig): AxiosPromise<SaveTransactionsResponse> {
            return localVarFp.createSingleOrMultiple(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a transaction
         * @summary Deletes an existing transaction
         * @param {TransactionsApiDeleteExistingTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExistingTransaction(requestParameters: TransactionsApiDeleteExistingTransactionRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionResponse> {
            return localVarFp.deleteExistingTransaction(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {TransactionsApiGetSingleTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(requestParameters: TransactionsApiGetSingleTransactionRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionResponse> {
            return localVarFp.getSingleTransaction(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {TransactionsApiImportLinkedAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedAccounts(requestParameters: TransactionsApiImportLinkedAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionsImportResponse> {
            return localVarFp.importLinkedAccounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {TransactionsApiListByAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByAccount(requestParameters: TransactionsApiListByAccountRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionsResponse> {
            return localVarFp.listByAccount(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {TransactionsApiListByCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByCategory(requestParameters: TransactionsApiListByCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<HybridTransactionsResponse> {
            return localVarFp.listByCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {TransactionsApiListByPayeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByPayee(requestParameters: TransactionsApiListByPayeeRequest, options?: AxiosRequestConfig): AxiosPromise<HybridTransactionsResponse> {
            return localVarFp.listByPayee(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {TransactionsApiListTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(requestParameters: TransactionsApiListTransactionsRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionsResponse> {
            return localVarFp.listTransactions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {TransactionsApiUpdateExistingTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExistingTransaction(requestParameters: TransactionsApiUpdateExistingTransactionRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionResponse> {
            return localVarFp.updateExistingTransaction(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {TransactionsApiUpdateMultipleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiple(requestParameters: TransactionsApiUpdateMultipleRequest, options?: AxiosRequestConfig): AxiosPromise<SaveTransactionsResponse> {
            return localVarFp.updateMultiple(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSingleOrMultiple operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCreateSingleOrMultipleRequest
 */
export type TransactionsApiCreateSingleOrMultipleRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiCreateSingleOrMultiple
    */
    readonly budgetId: string
    
} & PostTransactionsWrapper

/**
 * Request parameters for deleteExistingTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDeleteExistingTransactionRequest
 */
export type TransactionsApiDeleteExistingTransactionRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiDeleteExistingTransaction
    */
    readonly budgetId: string
    
    /**
    * The id of the transaction
    * @type {string}
    * @memberof TransactionsApiDeleteExistingTransaction
    */
    readonly transactionId: string
    
}

/**
 * Request parameters for getSingleTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetSingleTransactionRequest
 */
export type TransactionsApiGetSingleTransactionRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiGetSingleTransaction
    */
    readonly budgetId: string
    
    /**
    * The id of the transaction
    * @type {string}
    * @memberof TransactionsApiGetSingleTransaction
    */
    readonly transactionId: string
    
}

/**
 * Request parameters for importLinkedAccounts operation in TransactionsApi.
 * @export
 * @interface TransactionsApiImportLinkedAccountsRequest
 */
export type TransactionsApiImportLinkedAccountsRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiImportLinkedAccounts
    */
    readonly budgetId: string
    
}

/**
 * Request parameters for listByAccount operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListByAccountRequest
 */
export type TransactionsApiListByAccountRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiListByAccount
    */
    readonly budgetId: string
    
    /**
    * The id of the account
    * @type {string}
    * @memberof TransactionsApiListByAccount
    */
    readonly accountId: string
    
    /**
    * If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    * @type {string | Date}
    * @memberof TransactionsApiListByAccount
    */
    readonly sinceDate?: string | Date
    
    /**
    * If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    * @type {'uncategorized' | 'unapproved'}
    * @memberof TransactionsApiListByAccount
    */
    readonly type?: 'uncategorized' | 'unapproved'
    
    /**
    * The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    * @type {number}
    * @memberof TransactionsApiListByAccount
    */
    readonly lastKnowledgeOfServer?: number
    
}

/**
 * Request parameters for listByCategory operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListByCategoryRequest
 */
export type TransactionsApiListByCategoryRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiListByCategory
    */
    readonly budgetId: string
    
    /**
    * The id of the category
    * @type {string}
    * @memberof TransactionsApiListByCategory
    */
    readonly categoryId: string
    
    /**
    * If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    * @type {string | Date}
    * @memberof TransactionsApiListByCategory
    */
    readonly sinceDate?: string | Date
    
    /**
    * If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    * @type {'uncategorized' | 'unapproved'}
    * @memberof TransactionsApiListByCategory
    */
    readonly type?: 'uncategorized' | 'unapproved'
    
    /**
    * The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    * @type {number}
    * @memberof TransactionsApiListByCategory
    */
    readonly lastKnowledgeOfServer?: number
    
}

/**
 * Request parameters for listByPayee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListByPayeeRequest
 */
export type TransactionsApiListByPayeeRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiListByPayee
    */
    readonly budgetId: string
    
    /**
    * The id of the payee
    * @type {string}
    * @memberof TransactionsApiListByPayee
    */
    readonly payeeId: string
    
    /**
    * If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    * @type {string | Date}
    * @memberof TransactionsApiListByPayee
    */
    readonly sinceDate?: string | Date
    
    /**
    * If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    * @type {'uncategorized' | 'unapproved'}
    * @memberof TransactionsApiListByPayee
    */
    readonly type?: 'uncategorized' | 'unapproved'
    
    /**
    * The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    * @type {number}
    * @memberof TransactionsApiListByPayee
    */
    readonly lastKnowledgeOfServer?: number
    
}

/**
 * Request parameters for listTransactions operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListTransactionsRequest
 */
export type TransactionsApiListTransactionsRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiListTransactions
    */
    readonly budgetId: string
    
    /**
    * If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    * @type {string | Date}
    * @memberof TransactionsApiListTransactions
    */
    readonly sinceDate?: string | Date
    
    /**
    * If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    * @type {'uncategorized' | 'unapproved'}
    * @memberof TransactionsApiListTransactions
    */
    readonly type?: 'uncategorized' | 'unapproved'
    
    /**
    * The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    * @type {number}
    * @memberof TransactionsApiListTransactions
    */
    readonly lastKnowledgeOfServer?: number
    
}

/**
 * Request parameters for updateExistingTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUpdateExistingTransactionRequest
 */
export type TransactionsApiUpdateExistingTransactionRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiUpdateExistingTransaction
    */
    readonly budgetId: string
    
    /**
    * The id of the transaction
    * @type {string}
    * @memberof TransactionsApiUpdateExistingTransaction
    */
    readonly transactionId: string
    
} & PutTransactionWrapper

/**
 * Request parameters for updateMultiple operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUpdateMultipleRequest
 */
export type TransactionsApiUpdateMultipleRequest = {
    
    /**
    * The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    * @type {string}
    * @memberof TransactionsApiUpdateMultiple
    */
    readonly budgetId: string
    
} & PatchTransactionsWrapper

/**
 * TransactionsApiGenerated - object-oriented interface
 * @export
 * @class TransactionsApiGenerated
 * @extends {BaseAPI}
 */
export class TransactionsApiGenerated extends BaseAPI {
    /**
     * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
     * @summary Create a single transaction or multiple transactions
     * @param {TransactionsApiCreateSingleOrMultipleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public createSingleOrMultiple(requestParameters: TransactionsApiCreateSingleOrMultipleRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createSingleOrMultiple(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a transaction
     * @summary Deletes an existing transaction
     * @param {TransactionsApiDeleteExistingTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public deleteExistingTransaction(requestParameters: TransactionsApiDeleteExistingTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteExistingTransaction(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {TransactionsApiGetSingleTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public getSingleTransaction(requestParameters: TransactionsApiGetSingleTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getSingleTransaction(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
     * @summary Import transactions
     * @param {TransactionsApiImportLinkedAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public importLinkedAccounts(requestParameters: TransactionsApiImportLinkedAccountsRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).importLinkedAccounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {TransactionsApiListByAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public listByAccount(requestParameters: TransactionsApiListByAccountRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listByAccount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {TransactionsApiListByCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public listByCategory(requestParameters: TransactionsApiListByCategoryRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listByCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified payee
     * @summary List payee transactions
     * @param {TransactionsApiListByPayeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public listByPayee(requestParameters: TransactionsApiListByPayeeRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listByPayee(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns budget transactions
     * @summary List transactions
     * @param {TransactionsApiListTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public listTransactions(requestParameters: TransactionsApiListTransactionsRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single transaction
     * @summary Updates an existing transaction
     * @param {TransactionsApiUpdateExistingTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public updateExistingTransaction(requestParameters: TransactionsApiUpdateExistingTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateExistingTransaction(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates multiple transactions, by `id` or `import_id`.
     * @summary Update multiple transactions
     * @param {TransactionsApiUpdateMultipleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiGenerated
     */
    public updateMultiple(requestParameters: TransactionsApiUpdateMultipleRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateMultiple(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
